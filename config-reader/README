***********************************************************
*
*
*  C++ Config File Reader by Brandon Roberts
*  Version 1.1 Update : Slight Overhaul & Cleaning
*
*
***********************************************************

** Contains **
--------------
Harmony/config_reader/config_reader.h


** Isssues **
-------------
Listed as 'TO DO' in code


** Dependancies **
------------------
boost/lexical_cast.hpp
boost/algorithm/string/trim.hpp


** Compiling **
---------------
if included in main.cpp:

  g++ -c main.cpp -I ~/workspace
  g++ main.o -o main

  clang++ -c main.cpp -I ~/workspace
  clang++ main.o -o main

ie. Normal


** READ **
----------

This loads config settings designated in a passed file, loads all as strings and the value
  will be accessable by calling one of the as_* functions 
Note : Config_Reader determines values based on new line's no terminating symbols

NESTED SYNTAX : "conf_1::conf_2::conf_3::...::param_name"
  this indexing configs w/ key conf_1 => indexed Config_Reader's configs w/ key conf_2 => ...
  till last param_name which indexes last Config_Reader's params_ w/ key param_name
  i.e. using 'config_name.param(conf_1::conf_2::param_name);' is the same as 
             'config_name.config(conf_1).config(conf_2).param(param_name);'

** Interface **
----------------

Config_Reader :

  Construction : 
      Config_Reader name(string config_filename/path)

  Check if Config_Reader contains Config_Reader w/ key conf_name :
      bool has_config(string conf_name)
  Check if Config_Reader contains Parameter w/ param_name ( using nested syntax, see: READ ) :
      bool has_param(string param_name)

  To index contained Config Readers by key : 
      Config_Reader config(string conf_key)

  To index Parameters by key ( using nested syntax, see: READ ) : 
      Parameter param(string param_key)
      index operator : [string param_key]


Parameter : 

  Get Parameter value : 
      as_int(), as_int(int base), as_double(), as_float(), as_string(),
      as<Type>() -- uses lexical cast
      std::vector<Parameter> as_vector() -- ( ie value of form param_1, param_2, ... )
      std::map<std::string, Parameter> as_map() -- ( ie value of form key1 : val1, key2 : val2, ...)


** Example **
-----------

Note : Spacing doesn't matter, only indicators like, '{', '}', ':', ',' , ...

This is the layout of a config file, and what it will load:

"Config.conf"
  information: {

    cats: [ sam, bethany, tony ]
    hats: ( big : 100, med : 10, small : 1 )

    dog: ruffis
    Ignored line bc doesnt have colon character

    house: {

      bedroom : 4

      bathroom : 2

    }

  }

  info: {

    time: 15:00:00

  }

** end of file **

This loads:
  
  2 config readers, "information" and "info"
  
  information contains :
    
     3 parameters, "cats" has "sam, bethany, tony"
                   "hats" has "big: 100, med : 10, small : 1"
                   "dogs" has "ruffis"
    
     1 config reader, "house" which contains 2 parameters, "bedroom" and "bathroom"

   ...

use in main.cpp:

  #include "Harmony/config-reader/config_reader.h"
  #include <iostream>

  int main() {

    Config_Reader config("config.conf");

    std::cout << config["information::dog"].as_string() << "\n";
    if(config.has_param("information::house::bedroom"))
      std::cout << config["information::house::bedroom"].as_int() << "\n";
    if(config.has_param("information::bloop")) std::cout << "bloop\n";
    else std::cout << "Bleep\n";

    if(config.has_config("info")) { std::cout << "has info\n"; }
    if(config.has_config("dog")) { std::cout << "has dog\n"; }

    for(const auto& cat : config["information::cats"].as_vector()) {
      std::cout << cat.as_string() << "|";
    }
    std::cout << std::endl;

    std::cout << config["information::hats"].as_map()["med"].as<int>() << std::endl;
  }

  g++ -c main.cpp -I "~/workspace"
  g++ main.o -o main

  ./main

output :
  ruffis
  4
  Bleep
  has info
  sam|bethany|tony|
  10
